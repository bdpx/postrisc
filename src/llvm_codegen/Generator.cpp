#include "disassembler/Decoder.hpp"

#include "Generator.hpp"

namespace postrisc {
namespace llvm {

const char Generator::CHECK_LABEL[] = "// CHECK-LABEL: @";
const char Generator::CHECK[] = "// CHECK: ";
const char Generator::CHECK_NEXT[] = "// CHECK-NEXT: ";
const char Generator::CHECK_EMPTY[] = "// CHECK-EMPTY:";

void Generator::StartFile(std::ostream& out, const char *params)
{
    out << "// RUN: clang %cflags " << params << " %s | FileCheck %s" << std::endl;
    out << "// REQUIRES: postrisc-registered-target" << std::endl;
    out << std::endl;
    out << "// autogenerated, do not edit" << std::endl;
    out << "#include \"common.h\"" << std::endl;
    out << std::endl;
}

void Generator::CreateLitLocalCfg(void)
{
    std::ofstream out("lit.local.cfg");

const char content[] = R"ABRACADABRA(
config.suffixes = ['.c', '.cpp']

if not 'Postrisc' in config.root.targets:
    config.unsupported = True

target = 'postrisc'
cpu  = 'pv1'
code_model = 'medium'
tls_model = 'local-dynamic'

# FIXME: path changed
PROJECT_PATH='~/postrisc'
MUSL_PATH='{PROJECT_PATH}/musl'
MUSL_LIB_PATH='{PROJECT_PATH}/postrisc/utils/musl/postrisc'
MUSL_PATHS='-isystem {MUSL_PATH}/include -isystem {MUSL_PATH}/arch/postrisc -isystem {MUSL_LIB_PATH}/obj/include'

# -mllvm --enable-nullification=1
postrisc_flags = f'-mllvm --enable-block-merging=1 -mllvm --postrisc-enable-dense-calls=1 -mllvm --enable-move-merging=1'

cflags = f'--target={target} -mcpu={cpu} -fPIC -ffast-math -S -O2 -ffreestanding -fomit-frame-pointer -mllvm -verify-analysis-invalidation=0 {postrisc_flags} {MUSL_PATHS} -w -o -'
cxxflags = f'%cflags'

config.substitutions.insert(0, ('%cflags', f'{cflags}'))
config.substitutions.insert(0, ('%cxxflags', f'{cxxflags}'))

)ABRACADABRA";

    out << content;
}

void Generator::CreateCommonHeader(void)
{
    std::ofstream out("common.h");

const char content[] = R"ABRACADABRA(
#pragma once

#if !defined(__POSTRISC__)
#error "__POSTRISC__" isn't defined
#endif

#if !defined(__cplusplus)
#define bool _Bool
#define true 1
#define false 0
#endif

#if !defined(likely)
    #define likely(x)      __builtin_expect(!!(x), 1)
#endif

#if !defined(unlikely)
    #define unlikely(x)    __builtin_expect(!!(x), 0)
#endif

// macros to check branch instructions
#define CHECK_BRANCH(COND)               \
  if (unlikely(COND)) {                  \
    __builtin_postrisc_nul_never(111);   \
  } else {                               \
    __builtin_postrisc_nul_never(222);   \
  }

#define CHECK_INV_BRANCH(COND)           \
  if (likely(COND)) {                    \
    __builtin_postrisc_nul_never(333);   \
  } else {                               \
    __builtin_postrisc_nul_never(444);   \
  }

// macros to check nullification instructions
#define CHECK_NULLIFICATION(COND)              \
  if (unlikely(COND)) {                        \
    __builtin_postrisc_nop(555);               \
  } else {                                     \
    __builtin_postrisc_nop(666);               \
    __builtin_postrisc_nop(777);               \
  }

#define CHECK_INV_NULLIFICATION(COND)    \
  if (likely(COND)) {                    \
    __builtin_postrisc_nop(777);         \
  } else {                               \
    __builtin_postrisc_nop(888);         \
  }

typedef signed char i8;
typedef unsigned char u8;
typedef short i16;
typedef unsigned short u16;
typedef int i32;
typedef unsigned int u32;
typedef long long i64;
typedef unsigned long long u64;
typedef __int128_t i128;
typedef __uint128_t u128;

typedef _Float16 f16; // native support for ieee halffloat
typedef float f32;
typedef double f64;
typedef long double f128;

typedef void *PVOID;

typedef int (*ft0)();
typedef int (*ft)(int arg);

typedef __attribute__((ext_vector_type(8))) f16 v8f16;
typedef __attribute__((ext_vector_type(4))) f32 v4f32;
typedef __attribute__((ext_vector_type(2))) f64 v2f64;

typedef __attribute__((ext_vector_type(16))) i8 v16i8;
typedef __attribute__((ext_vector_type(8))) i16 v8i16;
typedef __attribute__((ext_vector_type(4))) i32 v4i32;
typedef __attribute__((ext_vector_type(2))) i64 v2i64;

typedef __attribute__((ext_vector_type(16))) u8 v16u8;
typedef __attribute__((ext_vector_type(8))) u16 v8u16;
typedef __attribute__((ext_vector_type(4))) u32 v4u32;
typedef __attribute__((ext_vector_type(2))) u64 v2u64;

typedef struct {
  i64 re;
  i64 im;
} complex;

extern int printf(const char* fmt, ...);
extern void exit(int);

#define BITCAST(TYPE) *(TYPE*)&
)ABRACADABRA";

    out << content;
}

void Generator::CreateGitIgnore(void)
{
    std::ofstream out(".gitignore");

    out << "generated*.c" << std::endl;
    out << "lit.local.cfg" << std::endl;
    out << "common.h" << std::endl;
}


class InstructionSorter {
public:
    InstructionSorter(EInstructionID _id) : id(_id) {}
    bool operator>(const InstructionSorter& r) const {
        return std::strcmp(insn_name(id), insn_name(r.id)) < 0;
    }
public:
    EInstructionID id;
};

int Generator::Run()
{
    CreateLitLocalCfg();
    CreateCommonHeader();
    CreateGitIgnore();

    static const struct {
        char name[64];
        char params[64];
        void (Generator::*func)(std::ostream& out);
    } handlers[] = {
#define X_TABLE(NAME, OPTIONS) { "generated_" #NAME ".c", OPTIONS, &Generator::NAME },
      DECLARE_CODEGEN_HANDLERS(X_TABLE)
#undef X_TABLE
    };

    for (const auto& h : handlers) {
        std::ofstream out(h.name);
        StartFile(out, h.params);
        (this->*h.func)(out);
    }

    std::vector<InstructionSorter> nontested;
    size_t tested = 0;
    size_t all = 0;
    for (size_t i=0; i < m_used.size(); i++) {
        const EInstructionID inst = static_cast<EInstructionID>(i);
        const EInstructionID realInsnId = Decoder::Decode(InstructionSingle(asm_info[inst].tmplt));
        if (inst == realInsnId) {
            ++all;
            tested += m_used[i];
            if (!m_used[i]) {
                nontested.emplace_back(static_cast<EInstructionID>(i));
            }
        }
    }
    std::sort(nontested.begin(), nontested.end(), std::greater<InstructionSorter>());

    std::cout << "All instructions - " << all
              << ", tested - " << tested
              << ", not tested - " << (all - tested)
              << std::endl;

    for (size_t i = 0; i < nontested.size(); i++) {
        std::cout << std::setw(20) << insn_name(nontested[i].id);
        if (i % 8 == 7) std::cout << std::endl;
    }

    std::cout << std::endl;
    return 0;
}

void Generator::used(EInstructionID insn)
{
    assert(insn < m_used.size());
    m_used[insn] = true;
}

} // namespace llvm
} // namespace postrisc

