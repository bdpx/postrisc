<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xhtml.xsl"?>

<chapter xmlns="http://www.example.com/postrisc" id="interrupts">
<title>Interrupts and hardware exceptions</title>

<preface>
<p><def>Interruption</def> is an action in which the processor automatically stops execution of the current instruction thread.
The processor usually saves part of the thread context (at least the address of the instruction must be saved,
with which the normal execution of the instruction flow should continue).
The state of the machine changes to a special interrupt processing mode.
The processor starts execution from the predefined address of the interruption handler routine.
Having finished the interrupt processing, the routine-handler (usually) restores the previous state of the processor (the context of the interrupted thread),
and makes it possible to continue execution of the thread with an interrupted (or following) instruction (return from interruption).
</p>

<p><def>Exception</def> is an event that, if enabled, forces the processor to interrupt.
Exceptions are generated by signals from internal and external peripheral devices, instructions of the processor itself,
internal timer, debugger events, or conditional errors.
In the general case, exceptions do not coincide with interrupts: different exceptions may
generate an interrupt of the same type, one exception can produce several interrupts.
</p>
</preface>

<section id="int_classif">
<title>Classification of interrupts</title>

<p>All interrupts can be classified according to the following independent characteristics:
location of the code for interrupt service, synchronism to the context, synchronism to the instruction flow, criticality, accuracy.
</p>

<p>According to the <def>code location</def> for its service, interrupts are divided into two groups.
Interrupts of the first group depend on the specific implementation of the processor and/or platform.
This is a RESET (power up, hardware or <quote>cold</quote> start)
INIT (soft or <quote>warm</quote> restart),
CHECK (test and, possibly, recovery of the processor and/or platform upon failure),
PMI (request to the processor/platform for a implementation specific service).
The method for handling such interrupts is unknown to the operating system.
The code for processing them is stored in an intermediate layer between the OS and the hardware (PAL).
The addresses of the handlers for such interrupts are fixed for this processor implementation,
and are tied to the address range of the PAL library.
The code, in whole or in part (if the implementation allows PAL updates) is sewn into the write-protected PAL memory area.
</p>

<p>Interrupts of the second group are determined by the architecture (fixed) and do not depend on the specific processor implementation.
The method of servicing such interrupts is selected by the operating system.
The code for their processing is stored in the interrupt table, the location address of this table and its contents are set by the OS.
Interrupts of the second group are also called <em>vector</em> interrupts,
since the processor uses the interrupt vector number to select the handler code from the interrupt table.
</p>

<p><def>Synchronism to the context</def> specifies the ability to continue the interrupted instruction flow.
For RESET or CHECK, the continuation of the interrupted execution context is impossible <ndash/> it either doesn't exist yet, or it is not restored.
A machine check (restart, reset) interrupts the actions of context synchronization with respect to subsequent instructions.
For other types of interrupts, after the interrupt is processed, the interrupted thread context is usually restored.
These interrupts are also called <def>context-synchronous</def> or <def>recoverable</def>.
This means that after the interruption is completed, execution can continue.
interrupted sequence of instructions (execution context is saved/restored).
An interrupt can be <def>unrecoverable</def> if during its generation or processing
The contents of the processor registers, cache memory, write buffers, etc will be lost.
</p>

<p><def>Synchronization to the thread</def> sets the relation of interruption to the interrupted instruction thread.
<def>Asynchronous to the thread</def> interrupts are caused by events that are not explicitly dependent on the instructions being executed.
For asynchronous interrupts, the address reported to the exception handling routine is
it is simply the address of the next thread instruction that would be executed next if the asynchronous interrupt did not occur.
<def>Synchronous to the thread</def> interrupts are caused directly by the execution or attempt to execute an instruction from the current thread.
Synchronous interrupts are processed strictly in software order, and if available
multiple interrupts for a single <ndash/> instruction in order of precedence for interrupts.
Thread-synchronous interrupts are divided into two classes: <def>errors</def> (or faults) and <def>traps</def>.
</p>

<p><def>Error</def> or fault is an interrupt that occurs before the instruction completes.
The current instruction cannot (or should not) be executed, or system intervention is required before the instruction is executed.
Errors are synchronous relative to the instruction flow.
The processor completes the state changes that occurred in the instructions before the erroneous instruction.
An erroneous instruction and subsequent instructions have no effect on the machine state.
Possible intermediate results of the instruction execution are completely canceled upon error,
and after processing the interrupt, the instruction restarts again.
Synchronous interrupt errors accurately indicate the address of the instruction that caused the exception that generated the interrupt.
</p>

<p><def>Trap</def> is an interrupt that occurs after the execution of an instruction.
A completed instruction requires systemic intervention.
Traps are synchronous relative to the instruction flow.
The trap instruction and all previous instructions are complete.
The following instructions have no effect on the machine condition.
The instruction that generated the trap is not canceled or restarted.
Synchronous trap traps accurately indicate the location of the next instruction after the instruction that raised the exception that threw the interrupt.
</p>

<p>When executing an instruction causes a trap or attempting to execute an instruction causes an error,
The following conditions must exist at the breakpoint:
</p>

<ul>
<li>All instructions preceding the instruction that raised the exception are accepted as executed for the interrupted processor.
However, the memory access operations associated with these previous instructions may not have yet been performed from the point of view of other processors and memory mechanisms.
Not a single instruction after the instruction that raised the exception has yet been accepted as executed.</li>

<li>The instruction that raised the exception either did not start execution (if it were not for raising an exception), or, completed, depending on the type of interrupt.
The register <reg>iip</reg> contains the address of the instruction bundle that generated the exception exception or instruction immediately after the instruction,
generated an exception trap.
Since the instruction that generated the error will be re-run, the <reg>iip</reg> register always contains the return address from the interrupt.
By the type of interrupt and status bits, you can determine whether this instruction is interrupted or next.</li>
</ul>

<p><def>Critical Interrupts</def>. Some types of interruptions require immediate attention,
even if other types of interrupts are currently being processed,
and it was not yet possible to save the state of the machine (return address and contents of the machine status registers).
In addition, the interrupt handler itself may generate an interrupt, which may require a new handler to process.
For example, when placing a page table in virtual memory when processing a miss in DTLB or ITLB, a DTLB may miss again.
</p>

<p>According to these requirements, interruptions can be classified by severity level.
To allow the possibility of a more critical interrupt immediately after the start of processing a less critical interrupt
(that is, before the state of the machine is saved),
provides several sets of shadow registers to save the state of the machine.
Interrupts for each criticality class use their own set of registers.
</p>

<p>All interrupts, except for machine verification, are ordered by two categories of interrupt criticality,
so that only one interrupt of each category is processed at a time,
and while it is being processed, no part of the program state will be lost.
Since the group of registers for saving/restoring the processor state upon interruption is a sequential reusable resource,
used by all interrupts of the same class, respectively, program status may be lost when an unordered interrupt occurs.
</p>

<p><def>Interrupt Accuracy</def> is an optional feature for synchronous interrupt flow.
<def>Exact interrupts</def> are issued on a predictable instruction.
The place where the instruction thread breaks is exactly the instruction that causes the synchronous event.
All previous instructions (in program order) are completed before passing control to the interrupt handler.
The instruction address is stored automatically by the processor.
When the interrupt handler completes execution, it returns to the interrupted program and restarts its execution from the interrupted instruction.
</p>

<p><def>Inaccurate interrupts</def> do not guarantee spawning on a predictable instruction.
Any instruction that was not yet executed when the interrupt occurred could be the place where the thread was interrupted.
Inaccurate interrupts can be considered asynchronous, because the source instruction of the interrupt doesn't necessarily refer to the interrupted instruction.
Inaccurate interrupts are <em>lagging</em> from the interrupted thread.
Inaccurate interrupts and their handlers usually collect information about the state of the machine,
related to interruption for reporting through the system diagnostic software.
An interrupted program usually doesn't restart (cannot be restored).
</p>

<table>
<caption>Classification of Interrupts</caption>
<thead><tr>
<th colspan="2" rowspan="3">PAL code (asynchronous to the thread or inaccurate, critical)</th>
<th colspan="5">Vector</th>
</tr><tr>
<th rowspan="3">Asynchronous to instruction thread, recoverable</th>
<th colspan="4">Synchronous to the thread</th>
</tr><tr>
<th colspan="2">Inaccurate errors</th>
<th colspan="2">Accurate, recoverable</th>
</tr><tr>
<th>Unrecoverable</th>
<th>Recoverable</th>
<th>Unrecoverable</th>
<th>Recoverable</th>
<th>Errors</th>
<th>Traps</th></tr>
</thead>
<tbody>
<tr>
<td>RESET, CHECK</td>
<td>INIT, PMI, CHECK</td>
<td>INT (external interrupts)</td>
<td>?</td>
<td>maybe FPU?</td>
<td>TLB, Access rights</td>
<td>Debug, FPU traps</td>
</tr>
</tbody>
</table>

<p>Since not all combinations of
handler code location,
synchronicity with the context and/or flow,
criticality and accuracy are exist,
it is convenient to divide all interrupts into four types:
failures (aborts), asynchronous interrupts (interrupts), and synchronous interruptions (interruptions),
which are also divided into errors (faults) and traps (traps).
</p>

<p><def>Failures</def>. The processor has detected an internal failure, or a processor reset has been requested.
A crash is not synchronous to the context or the instruction flow.
A crash can leave the current instruction thread in an unpredictable state with partially modified registers and/or memory.
Crashes are PAL-stored interrupts.
</p>

<ul>
<li>Machine Checks (MCA). The processor has detected a hardware error that requires immediate action.
Depending on the type and severity of the error, the processor may be able to correct the error and continue execution.
PAL-CHECK entry point to try to fix the error.</li>
<li>Processor Reset (RESET): The processor was turned on or a reset request was sent.
PAL-RESET entry point for the processor to perform a system self-test and initialization.</li>
</ul>

<p><def>Asynchronous Interrupts</def>.
An external or independent entity (such as an IO device, its own timer, or another processor) needs attention.
Interrupts are asynchronous relative to the instruction flow, but usually synchronous with the context, all previous instructions are completed.
Current and subsequent instructions have no effect on the machine condition.
Interrupts are divided into initialization interrupts, platform control interrupts, and external interrupts.
Initialization and interrupts for platform management are PAL interrupts, external interrupts are vectored interrupts.</p>

<ul>
<li>Interrupt initialization (INIT). The processor received an initialization request.
PAL-INIT is executed, and the processor is brought to the specified state.</li>

<li>A platform management request to execute functions such as platform error handling, memory cleaning, or power management.
PAL-PMI is performed to serve the request.
Program execution can continue at the breakpoint.
Platform management interruptions are distinguished by unique vector numbers.
Vectors 0-3 are reserved for the platform software, vectors 4-15 are reserved for the processor software.</li>

<li>External interrupts (INT).
The processor received a service request.
Typically, these requests come from IO devices, although requests can come from any other processor in the system, including itself.
To process such a request, an external interrupt vector is used.
External interrupts are distinguished by unique vector numbers in the range from 16 to 255.
These vector numbers are used to distinguish external interrupts by source and priority.
Special case of external interrupts are non-maskable interrupts (NMI),
which are used to request critical by priority operating system services.
NMI interrupts are assigned vector number 2 of external interrupts.</li>
</ul>

<p><def>Errors</def> and <def>traps</def>.
Always synchronous with context and flow. These are vector interrupts.
</p>

<p>Machine check interruption is a special case of asynchronous interruption.
They are usually caused by some hardware, or by a failure of the memory subsystem, or by trying to access an invalid address.
Machine verification can be called indirectly by executing an instruction,
if the error caused by the execution of the instruction will not be recognized on time and will turn into a hardware failure.
The fact that machine verification interrupts cannot be said to be synchronous or asynchronous, as accurate or inaccurate.
They, however, are treated as critical class interrupts.
</p>

<p>In the case of machine verification, the following general rules apply:
1. No instruction after the one whose address is communicated to the verification interrupt routine in the <reg>iip</reg> register has started execution.
2. The instruction whose address is communicated to the machine check interrupt routine
in the register <reg>iip</reg>, and all previous instructions may or may not be completed successfully.
All those instructions that are ever going to complete seem to be
will do so already, and have done so within the context existing prior to the Machine Interruption of the Verification.
No further interruption (other than new machine check interruptions) will occur as a result of those instructions.
</p>

</section>

<section id="int_state">
<title>Processor state preservation upon interruption</title>

<p>When an interrupt occurs, the processor saves in special registers part of the context of the interrupted instruction stream.
This is necessary for the subsequent correct restoration of the interrupted stream after completion of the interrupt processing.
These are the registers: <reg>iip</reg> is a copy of <reg>ip</reg>, <reg>ipsr</reg> is a copy of <reg>psr</reg>.
</p>

<p>The processor provides the interrupt handler with some minimum free registers for intermediate computations,
so that the interrupt handler can use these registers for its own purposes.
Special registers group <reg>ifa</reg>, <reg>cause</reg>, <reg>iib</reg>
stores information about the characteristics of the interrupt necessary to recognize and process the interrupt.
</p>

<p>Special Registers Group (<reg>iip</reg>, <reg>iipa</reg>, <reg>ipsr</reg>, <reg>ifa</reg>, <reg>cause</reg>, <reg>iib</reg>)
used to quickly save part of the machine state during interruptions,
service interrupt, and restore the initial state of the machine when returning from the interrupt.
This group exists in two instances to service two level interrupts.
priority (criticality) and forms a file of 2 banks with 16 special registers.
</p>

<p>These registers store information during interruption and are used by interrupt handlers.
These registers can only be read or written while <regfield>psr.ic</regfield>=0 (while interrupt processing is in progress),
otherwise the error <error>Illegal Operation fault</error> occurs.
For these registers, their contents are guaranteed to be saved only when <regfield>psr.ic</regfield>=0.
When <regfield>psr.ic</regfield>=1, the processor doesn't save their contents.
</p>

<p>Special register <regname>interruption instruction pointer</regname> (<reg>iip</reg>) saves a copy of the register upon interruption
<reg>ip</reg> and indicates the place of return from the interrupt.
In general, <reg>iip</reg> contains the address of the instruction bundle,
which contains the instruction that caused the error, or the address of the bundle that contains the next instruction to return after processing the trap.
The specified and the following instructions are restarted; previous ones are ignored.
Outside of the interrupt context, the value of this register is undefined.
</p>

<p>Special register <regname>interruption instruction previous address</regname> (<reg>iipa</reg>), when interruption occurs,
saves the address of the last successfully executed (all slots) instruction bundle.
</p>

<reg_table>
<caption>Register format <reg>iip</reg> and <reg>iipa</reg></caption>
<bits64/>
<reg_row>
    <imm size="60">bundle address</imm>
    <reserved size="4">0</reserved>
</reg_row>
</reg_table>

<p>Special register <regname>interruption processor status register</regname> (<reg>ipsr</reg>)
upon interruption, it saves a copy of the register <reg>psr</reg> (machine status), and has the same format and set of fields as <reg>psr</reg>.
<reg>ipsr</reg> is used to restore processor state
when returning from interrupt with the instruction <mim>rfi</mim> (return from interruption).
</p>

<p>Special register <regname>interruption extended register</regname>
(<reg>cause</reg>) during non-critical (primary) interruption stores information about the interruption that occurred.
The <reg>cause</reg> register contains data for an exception to differentiate between the different types of exceptions that a single type of interrupt can generate.
When one of these interrupts is raised, the bits or bits corresponding to the particular exception that generated the interrupt will be set,
and all other bits of the register <reg>cause</reg> are cleared.
Other types of interruption do not affect the contents of the register <reg>cause</reg>.
The register <reg>cause</reg> must not be cleared by software.

The register <reg>cause</reg> stores information about the nature of the interrupt,
and recorded by the processor on all interrupt events, regardless of <regfield>psr.ic</regfield>, except for <error>Data Nested TLB faults</error>.
<reg>cause</reg> stores information about an interrupted instruction and its properties, such as read, write, execute, speculative, or non-access.
Several bits can be simultaneously set to <reg>cause</reg>,
for example, an erroneous semaphore operation can expose both <regfield>cause.r</regfield> and <regfield>cause.w</regfield>.
Additional information about the bug or trap is available through <regfield>cause.code</regfield> and <regfield>cause.vector</regfield>.
</p>

<reg_table>
<caption>Register format <reg>cause</reg></caption>
<hibits/>
<reg_row>
    <reserved size="24">reserved</reserved>
    <imm size="8">vector</imm>
</reg_row>
<bits32/>
<reg_row>
    <imm size="16">code</imm>
    <reserved size="8">reserved</reserved>
    <bitfield size="2">ei</bitfield>
    <bitfield>d</bitfield>
    <bitfield>n</bitfield>
    <bitfield>a</bitfield>
    <bitfield>r</bitfield>
    <bitfield>w</bitfield>
    <bitfield>x</bitfield>
</reg_row>
</reg_table>

<table>
<caption>Register Fields <reg>cause</reg></caption>
<thead><tr>
<th>Field</th>
<th>Bit</th>
<th>Description</th></tr>
</thead><tbody>
<tr><td>r</td><td>1</td><td><def>Read exception</def>. If 1, then the interrupt is associated with reading data.</td></tr>
<tr><td>w</td><td>1</td><td><def>Write exception</def>. If 1, then the interrupt is associated with data recording.</td></tr>
<tr><td>x</td><td>1</td><td><def>Execute exception</def>. If 1, then the interrupt is associated with fetch instructions.</td></tr>
<tr><td>n</td><td>1</td><td><def>Non-access</def> <ndash/> translation request instructions (<mim>dcbf</mim>, <mim>fetch</mim>, <mim>mprobe</mim>, <mim>tpa</mim>).</td></tr>
<tr><td>d</td><td>1</td><td><def>Exception Deferral</def> <ndash/>
this bit is set to TLB exception deferral bit (<regfield>tlb.ed</regfield>) for a code page containing an erroneous instruction.
If translation doesn't exist or translation for the code is prohibited, <regfield>cause.ed</regfield>=0.
If 1, then the interrupt is delayed.</td></tr>
<tr><td>ei</td><td>2</td>
<td><def>Excepting Instruction</def> is the slot number of the bundle on which the interrupt occurred.
For errors and external interrupts, <regfield>cause.ei</regfield>=<regfield>iip.sn</regfield> but doesn't match traps.
For traps, <regfield>cause.ei</regfield> defines the instruction slot for the trap.
</td></tr>
<tr><td>code</td><td>16</td><td><def>interruption Code</def> is the 16-bit code for additional information about the current interrupt.</td></tr>
<tr><td>vector</td><td>8</td><td>8-bit code for additional information about external interrupt.</td></tr>
</tbody></table>

<note>The information in the register <reg>cause</reg> is not complete.
System software may also need to identify the type of instruction
which caused the interrupt, examine the TLB input accessed by data or instruction memory access,
to fully determine which exception or exceptions caused the interrupt.
For example, a data memory interruption can be caused by both security breach exceptions, as well as byte order exclusions.
System software would have to look besides <reg>cause</reg>,
type of status <reg>psr</reg> in <reg>ipsr</reg> and page protection bits in the TLB input accessed by memory access,
to determine if a Defense Violation has also occurred.
The bits of the stored register <reg>ipsr</reg> can be changed when returning from an interrupt via <mim>rfi</mim>.
</note>

<p>Special register <regname>interruption faulting address</regname> (<reg>ifa</reg>)
upon interruption provides the effective address calculated by the interrupted instruction (virtual, or physical if translation is not used).
For loads, stores, atomics, or cache management instructions,
which caused an interrupt while accessing memory due to misalignment,
a miss in TLB data/instructions or for any other reason,
<reg>ifa</reg> contains an erroneous data address and points to the first byte of an erroneous operand.
For other instructions, <reg>ifa</reg> contains the address of the instruction bundle.
For erroneous instruction addresses, <reg>ifa</reg> stores a 16-byte boundary aligned binding address for the erroneous instruction.
<reg>ifa</reg> is also used to temporarily store the translation virtual address,
when the translation input is inserted into the TLB translation table (instructions or data).</p>

<p>Special 128-bit register <regname>interruption instruction bundle</regname> (<reg>iib</reg>) upon interruption,
if <regfield>psr.ic</regfield>=1, saves the current instruction bundle for the failed instruction.
The interrupt handler may use <reg>iib</reg> if needed to disassemble the failed instruction and emulate its execution.
</p>

<reg_table>
<caption>Register format <reg>iib</reg></caption>
<bits64/>
<reg_row>
 <imm size="20">slot2</imm>
 <imm size="42">slot1</imm>
 <imm size="2">tp</imm>
</reg_row>
<reg_row>
 <imm size="42">slot3</imm>
 <imm size="22">slot2</imm>
</reg_row>
</reg_table>

</section>

<section id="int_priority">
<title>Exception Priority</title>

<p>There are two types of exceptions: those caused directly by the execution of an instruction (synchronous to the instruction stream) or caused by asynchronous events.
In both cases, an exception can cause one of several types of interrupts.
</p>

<p>The architecture requires that all synchronous interrupts be processed programmatically according to a sequential execution model.
The exception to this rule is in the case of multiple synchronous interrupts from a single instruction.
</p>

<p>For any instruction trying to raise several exceptions for which the corresponding synchronous interrupt types are allowed,
a priority order is defined in which the instruction is allowed to generate single interrupts.
This exception priority mechanism, apart from the requirement that synchronous interrupts be generated programmatically,
also ensures that at any given time only one of the synchronous interrupt types exists for consideration.
The exception priority mechanism also prevents some debug exceptions
exceptions that occur in combination with other synchronously generated interrupts.
</p>

<p>This section doesn't define the allowed installation of multiple exceptions for which the corresponding interrupt types are blocked.
Throwing exceptions for which the corresponding interrupt types are blocked has no effect on throwing other exceptions,
for which appropriate interrupt types are allowed.
Conversely, if a specific exception for which the appropriate type of interrupt is enabled is shown in the following sections,
has a higher priority than another exception, this will prevent the installation of this other exception, regardless of
the corresponding type of interruption of another exception is allowed or blocked.
</p>

<p>The priority of exception types is listed below from highest to lowest.
Some types of exceptions can be mutually exclusive and can be considered as exceptions of the same priority.
In these cases, the exceptions are listed according to the sequential execution model.
</p>

<table>
<caption>Priority exception types</caption>
<thead><tr>
<th width="14%">Type</th>
<th>No.</th>
<th width="30%">Exception</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2">Aborts</td>
<td>1</td><td>Machine reset abort (RESET)</td><td>Reboot</td></tr>
<tr><td>2</td><td>Machine check abort (CHECK)</td><td>Processor check</td></tr>
<tr>

<td rowspan="3">External Interrupts</td>
<td>3</td><td>Initialization interrupt (INIT)</td><td>Warm restart</td></tr><tr>
<td>4</td><td>Platform management interrupt (PMI)</td><td>Platform interrupt (chipset, board)</td></tr><tr>
<td>5</td><td>External interrupt (INT)</td><td>External devices, timer, other processors</td></tr><tr>

<td rowspan="9">Runtime errors for the asynchronous register stack (spill-fill faults)</td>
<td>7</td><td>RS Data debug fault</td><td>Address and memory access match with one of the debug registers</td></tr><tr>
<td>8</td><td>RS Unimplemented data address fault</td><td>The presence of non-zero bits in the unimplemented bits of the address</td></tr><tr>
<td>10</td><td>RS Data TLB Alternate fault</td><td>Miss in TLB data (without HPT)</td></tr><tr>
<td>11</td><td>RS Data HPT fault</td><td>HPT error</td></tr><tr>
<td>12</td><td>RS Data TLB fault</td><td>Missing TLB data (after HPT)</td></tr><tr>
<td>13</td><td>RS Data page not present fault</td><td>Data page is not in physical memory</td></tr><tr>
<td>16</td><td>RS Data access rights fault</td><td>Accessing a virtual memory page in an unauthorized way, for example, reading from a page for which reading is prohibited</td></tr><tr>
<td>17</td><td>RS Data access bit fault</td><td>Access to the virtual memory page (first entry)</td></tr><tr>
<td>18</td><td>RS Unsupported data reference fault</td><td>Data access is not supported by memory attributes</td></tr><tr>

<td rowspan="6">Fetch faults phase errors</td>
<td>21</td><td>Instruction TLB Alternate fault</td><td>Miss in TLB instructions (without HPT)</td></tr><tr>
<td>22</td><td>Instruction HPT fault</td><td>HPT error</td></tr><tr>
<td>23</td><td>Instruction TLB fault</td><td>Missing TLB instructions (after HPT)</td></tr><tr>
<td>24</td><td>Instruction Page Not Present fault</td><td>The instruction page is not in physical memory</td></tr><tr>
<td>25</td><td>Instruction Access rights fault</td><td>Selection of instructions from the virtual memory page for which execution is not allowed</td></tr><tr>
<td>26</td><td>Instruction Access Bit fault</td><td>Fetching instructions from the virtual memory page (first fetch)</td></tr><tr>

<td rowspan="6">Decode faults errors</td>
<td>27</td><td>Illegal operation fault</td><td>Reserved instruction</td></tr><tr>
<td>28</td><td>Privileged operation fault</td><td>Privileged instruction</td></tr><tr>
<td>29</td><td>Undefined operation fault</td><td>Invalid instruction form</td></tr><tr>
<td>30</td><td>Disabled floating-point fault</td><td>Forbidden FP instruction</td></tr><tr>
<td>31</td><td>Unimplemented operation fault</td><td>Unimplemented standard instruction (emulation required)</td></tr><tr>
<td>32</td><td>Unsupported operation fault</td><td>Unimplemented dedicated instruction (emulation required)</td></tr><tr>

<td rowspan="8">execute faults</td>
<td>33</td><td>Reserved register/field fault</td><td>Invalid instruction field value (in particular register number)</td></tr><tr>
<td>34</td><td>Out-of-frame rotated register</td><td>Access to the rotated register outside the local frame</td></tr><tr>
<td>35</td><td>Privileged register fault</td><td>Attempt of an unprivileged program to perform a privileged operation with a privileged register</td></tr><tr>
<td>36</td><td>Invalid register field fault</td><td>Attempt to write an invalid value to registers, TLB</td></tr><tr>
<td>37</td><td>Virtualization fault</td><td>Attempted to execute a special instruction in processor virtualization mode</td></tr><tr>
<td>38</td><td>Integer overflow fault</td><td>Integer overflow</td></tr><tr>
<td>39</td><td>Integer divide by zero fault</td><td>Integer division by zero</td></tr><tr>
<td>40</td><td>floating-point fault</td><td>Floating-point error</td></tr><tr>

<td rowspan="10">execute faults memory access</td>
<td>42</td><td>Data debug fault</td><td>Address and memory access match with one of the debug registers</td></tr><tr>
<td>43</td><td>Unimplemented data address fault</td><td>The presence of non-zero bits in the unimplemented bits of the address</td></tr><tr>
<td>44</td><td>Data TLB Alternate fault</td><td>Missing TLB data (without HPT)</td></tr><tr>
<td>45</td><td>Data HPT fault</td><td>HPT error</td></tr><tr>
<td>46</td><td>Data TLB fault</td><td>Missing data TLB (after HPT)</td></tr><tr>
<td>47</td><td>Data page not present fault</td><td>Data page not in physical memory</td></tr><tr>
<td>48</td><td>Data access rights fault</td><td>Accessing the virtual memory page in an unauthorized way, such as reading from a page for which reading is prohibited</td></tr><tr>
<td>49</td><td>Data access bit fault</td><td>Access to the virtual memory page (first entry)</td></tr><tr>
<td>50</td><td>Unaligned data reference fault</td><td>Accessing data at an unaligned address</td></tr><tr>
<td>51</td><td>Unsupported data reference fault</td><td>Data access is not supported by memory attributes</td></tr><tr>

<td rowspan="8">Traps (traps)</td>
<td>53</td><td>Lower-Privilege Transfer trap</td><td>Debugger, privilege level change</td></tr><tr>
<td>54</td><td>Taken branch trap</td><td>Debugger, taken branch</td></tr><tr>
<td>55</td><td>Instruction Debug trap</td><td>Debugger, attempt to jump to an address that corresponds to one of the address ranges in debug registers</td></tr><tr>
<td>56</td><td>System call trap</td><td>Debugger, intercept system call</td></tr><tr>
<td>57</td><td>Single step trap</td><td>Debugger, trap after each instruction</td></tr><tr>
<td>58</td><td>Unimplemented Instruction address trap</td><td>Unimplemented address of the next instruction bundle</td></tr><tr>
<td>59</td><td>floating-point trap</td><td>Floating-point instruction requires intervention</td></tr><tr>
<td>60</td><td>software trap</td><td>Software trap (<mim>trap</mim>) instruction</td></tr>
</tbody>
</table>

<p>If an instruction raises multiple debug exceptions and doesn't raise any other exceptions,
then it is permissible to generate a single debug interrupt (highest priority).
</p>

</section>

<section id="int_deliver">
<title>Interrupt handling</title>

<p>The start addresses for interrupt handler code can be fixed in the architecture (old ARM, MIPS).
But it is desirable to provide the ability to switch the entry point (for example, for updating),
and also, possibly, for assigning different handlers to different processors in a multiprocessor system,
since in a multiprocessor system simultaneous processing of several interrupts by different processors can occur,
and no processor can use shared memory blocks for the needs of its interrupt handler.
Special register <regname>interruption vector address</regname> (<reg>iva</reg>)
determines the position of the system table of interrupt handlers in the virtual address space
(or the physical address space if translation disabled).
The vector table is 64 KiB in size and needs to be aligned on the 64 KiB border, so the lower 16 bits of the register must be zeros.
</p>

<reg_table>
<caption>Register format <reg>iva</reg></caption>
<bits64/>
<reg_row>
    <imm size="48">iva</imm>
    <reserved size="16">0</reserved>
</reg_row>
</reg_table>

<p>For each of the 64 types of interrupts in the table, 1024 bytes of code are allocated (64 bundles or 192 short instructions).
The address of the interrupt handler is obtained by combining the register <reg>iva</reg> and the interrupt vector number inum.
If some vector is not used, then the place for its code in the table can use the vector preceding by the number.
If, nevertheless, the interrupt handler doesn't fit in the table, a transition outside the vector table should be implemented.</p>

<reg_table>
<caption>Address of the interrupt handler</caption>
<bits64/>
<reg_row>
    <imm size="48">IVA base</imm>
    <bitfield size="6">inum</bitfield>
    <reserved size="10">0</reserved>
</reg_row>
</reg_table>

<p>Interrupt handling is implemented as a quick context switch
(much simpler than completely changing the context of the process).
When an interrupt occurs, the hardware does the following:
</p>

<ol>
<li>If <regfield>psr.ic</regfield>=1, the register <reg>psr</reg> is stored in <reg>ipsr</reg>.</li>
<li>If <regfield>psr.ic</regfield>=1, the register <reg>ip</reg> is stored in <reg>iip</reg>,
and the address is saved in the register <reg>iipa</reg> the last fully executed instruction bundle (previous <reg>ip</reg>).
</li>
<li>If <regfield>psr.ic</regfield>=1, the interrupted instruction (or its first slot for the long instruction) is stored in <reg>iir</reg>.</li>
<li>If <regfield>psr.ic</regfield>=1 and there is an effective address associated with the interrupted instruction
(load/store instructions, atomic memory operations, transitions), this address is copied to <reg>ifa</reg>.
</li>
<li>In <regfield>cause.ei</regfield>, the slot number that caused the interrupt is stored.</li>
<li>Other additional information about the interrupted instruction is stored in <reg>cause</reg>.</li>
<li>In <regfield>psr.ri</regfield>, a mask of instructions is saved to continue working after interruption from the middle of the link.</li>
<li>The <regfield>psr.ic</regfield> bit is cleared (the ban on saving the state for subsequent critical interrupts is introduced).</li>
<li>The <regfield>psr.i</regfield> bit is cleared (prohibition of other interrupts).</li>
<li>The current privilege level <regfield>psr.cpl</regfield> changes to the kernel level (zero).</li>
<li>Execution continues from the address: <formula><reg>iva</reg> + (1024 <times/> interruption_number)</formula>.</li>
</ol>

<p>interruption_number is a unique integer value assigned to each interrupt.
Vectorization is done by going to the interrupt vector table indexed by this integer.
The interrupt vector table contains 1024 bytes (64 instruction bundles) for each interrupt processing routine.
The value in the register <reg>iva</reg> should be aligned on the page border of 64 kilobytes.
</p>

<note>The task of interrupt handlers is to resolve (unmask)
external interrupts (by setting the <regfield>psr.i</regfield> bit to 1) as soon as possible,
to minimize the worst latency for external interrupts.
</note>

<p>At the end of the interrupt routine, <mim>rfi</mim> (<miname>return from interruption</miname>) is executed
which restores the state register of the machine <reg>psr</reg> from <reg>ipsr</reg>,
and normal instruction execution resumes from the address contained in <reg>iip</reg>.
</p>

<!--
<note>In general, when switching a process, the operating system should consider the following:
memory serialization instructions should ensure that all memory operations
the interrupted process will be completed relative to other processors,
if the interrupted process will be executed on another processor.
The isync, rfi, or rfci instructions ensure that instructions in the new process are executed in a new context.</note>
-->
</section>
</chapter>
